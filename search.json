[{"title":"SSM-Spring框架学习","date":"2021-06-26T14:10:47.498Z","url":"/2021/06/26/SSM-Spring/","tags":[["SSM","/tags/SSM/"]],"categories":[["SSM","/categories/SSM/"]],"content":"SSM-Spring框架学习一、概念​ Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。 二、优点1、Spring是一个开源免费的框架 , 容器 . 2、Spring是一个轻量级的框架 , 非侵入式的 . 3、控制反转 IoC , 面向切面 Aop 4、对事物的支持 , 对框架的支持 三、组成3.1 Spring 框架是一个分层架构​ 由 7 个定义良好的模块组成，Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 . 3.2 组成 Spring 框架的每个模块（或组件）都可以单独存在： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 拓展 Spring Boot与Spring Cloud Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务; Spring Cloud是基于Spring Boot实现的； Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。 SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。 四、控制反转（IOC）4.1 本质 控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI） IoC是Spring框架的核心内容 ​ Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。&lt;**在配置文件加载的时候，容器中管理的对象就已经初始化了**&gt; ​ 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 五、快速上手Spring5.1 配置环境 导入Jar包 ​ 注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 (包含测试依赖). 5.2 编写代码​ 1、编写一个Hello实体类 ​ 2、编写我们的spring文件 , 这里我们命名为beans.xml ​ 3、我们可以去进行测试了 . 思考 Hello 对象是谁创建的 ? 【hello 对象是由Spring创建的 Hello 对象的属性是怎么设置的 ? hello 对象的属性是由Spring容器设置的 这个过程就叫控制反转 : 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 反转 : 程序本身不创建对象 , 而变成被动的接收对象 . 依赖注入 : 就是利用set方法来进行注入的. IOC是一种编程思想，由主动的编程变成被动的接收 可以通过newClassPathXmlApplicationContext去浏览一下底层源码 . 5.3 IOC创建对象方式5.3.1 通过无参构造方法来创建1、User.java 2、beans.xml 3、测试类 结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！ 5.3.2 通过有参构造方法来创建1、UserT . java 2、beans.xml 有三种方式编写 3、测试 结论：在配置文件加载的时候。其中管理的对象都已经初始化了！ 六、Spring配置6.1 别名alias 设置别名 , 为bean设置别名 , 可以设置多个别名 6.2 Bean的配置 6.3 import团队的合作通过import来实现 . 七、依赖注入（DI）7.1 概念 依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 . 注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 . 7.2 Set注入​ 要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is . 测试pojo类 : Address.java Student.java 7.2.1 常量注入 测试： 7.2.2 Bean注入注意点：这里的值是一个引用，ref 7.2.3 数组注入 7.2.4 List注入 7.2.5 Map注入 7.2.6 set注入 7.2.7 Null注入 7.2.8 Properties注入 扩展：Properties和Map都是以键值对的形式存储的，但是他们有什么区别吗？ ​ 最大的区别就是 Properties可以直接导入IO流 读取IO流中的数据 并且能把自己的元素输出到IO流中。就是我们可以去写properties文件，进行读写。 7.3 p命名和c命名注入7.3.1 P命名空间注入 : 需要在头文件中加入约束文件 7.3.2 c 命名空间注入 : 需要在头文件中加入约束文件 7.4 Bean的作用域​ 在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 . 7.4.1 Singleton​ 当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。 7.4.2 Prototype​ 当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。 对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域 补充：scope中单例（singleton）和prototype的优缺点：​ singleton（默认）:优点：不会new对象，节省资源；缺点：在处理高并发的时候可能会延迟或数据不一致​ prototype:优点：多线程稳定 缺点：每次在创建浪费资源 多线程使用prototype，单线程使用singleton 7.4.3 Request​ 当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例。即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。 ​ 针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效。当处理请求结束，request作用域的bean实例将被销毁。 7.4.3 Session​ 当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 ​ 针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效. 八、自动装配8.1 概念 自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。 8.2 装配机制Spring中bean有三种装配机制，分别是： 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。 8.3 实现Spring的自动装配需要从两个角度来实现，或者说是两个操作： 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI； 1、新建一个项目 2、新建两个实体类，Cat Dog 都有一个叫的方法 3、新建一个用户类 User 4、编写Spring配置文件 5、测试 8.3.1 autowire byName (按名称自动装配)​ 由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。 ​ 采用自动装配将避免这些错误，并且使配置简单化。 测试： ​ 1、修改bean配置，增加一个属性 autowire=”byName” ​ 2、再次测试，结果依旧成功输出！ ​ 3、我们将 cat 的bean id修改为 catXXX ​ 4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。 小结： 当一个bean节点带有 autowire byName的属性时。 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 去spring容器中寻找是否有此字符串名称id的对象。 如果有，就取出注入；如果没有，就报空指针异常。 8.3.2 autowire byType (按类型自动装配)使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。NoUniqueBeanDefinitionException 测试： 1、将user的bean配置修改一下 ： autowire=”byType” 2、测试，正常输出 3、在注册一个cat 的bean对象！ 4、测试，报错：NoUniqueBeanDefinitionException 5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。 九、使用注解9.1 配置jdk1.5开始支持注解，spring2.5开始全面支持注解。 准备工作：利用注解的方式注入属性。 1、在spring配置文件中引入context文件头 2、开启属性注解支持！ 9.2 @Autowired @Autowired是按类型自动转配的，不支持id匹配。 需要导入 spring-aop的包！ 测试： 1、将User类中的set方法去掉，使用@Autowired注解 2、此时配置文件内容 3、测试，成功输出结果！ 【补充】 @Autowired(required=false) 说明：false，对象可以为null；true，对象必须存对象，不能为null。 9.3 @Qualifier @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配 @Qualifier不能单独使用。 测试实验步骤： 1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！ 2、没有加Qualifier测试，直接报错 3、在属性上添加Qualifier注解 测试，成功输出！ 9.4 @Resource @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。 实体类： beans.xml 测试：结果OK 配置文件2：beans.xml ， 删掉cat2 实体类上只保留注解 结果：OK 结论：先进行byName查找，失败；再进行byType查找，成功。 9.5 @Nullable &lt;补充&gt;​ 字段标记了这个注解，说明这个字段可以为null 小结@Autowired与@Resource异同： 1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。 2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用 3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。 十、使用注解开发10.1 配置​ 在spring4之后，想要使用注解形式，必须得要引入aop的包 ​ 在配置文件当中，还得要引入一个context约束 10.2 bean的实现1、配置扫描哪些包下的注解 2、在指定包下编写类，增加注解 3、测试 10.3 属性注入使用注解注入属性 1、可以不用提供set方法，直接在直接名上添加@value(“值”) 2、如果提供了set方法，在set方法上添加@value(“值”); 10.4 衍生注解@Component三个衍生注解 为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。 @Controller：web层 @Service：service层 @Repository：dao层 写上这些注解，就相当于将这个类交给Spring管理装配了！ 10.5 作用域@scope singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 小结：XML与注解比较 XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 xml与注解整合开发 ：推荐最佳实践 xml管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解 作用： 进行注解驱动注册，从而使注解生效 用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册 如果不扫描包，就需要手动配置bean 如果不加注解驱动，则注入的值为null！ 10.6 基于Java类进行配置​ JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。 测试： 1、编写一个实体类，Dog 2、新建一个config配置包，编写一个MyConfig配置类 3、测试 导入其他配置如何做呢？ 1、我们再编写一个配置类！ 2、在之前的配置类中我们来选择导入这个配置类 "},{"title":"SSM-Mybatis框架学习","date":"2021-06-24T19:38:26.449Z","url":"/2021/06/25/SSM-Mybatis/","tags":[["SSM","/tags/SSM/"]],"categories":[["SSM","/categories/SSM/"]],"content":"SSM-Mybatis框架学习一、框架1.1 什么是框架​ 框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。 ​ 简而言之，框架其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。 2.2 MVC设计思想 什么是MVC？ M(Model模型)V(View视图)C(Controller控制器)开发模型 二、Mybatis 框架快速入门2.1创建 maven 工程 2.2 添加 Mybatis3.4.5 的坐标 2.3创建User实体类2.4编写持久层接口UserDao(内部写方法)2.5 编写持久层接口的映射文件 IUserDao.xml（SQL语句等配置信息）2.6 编写 SqlMapConfig.xml 配置文件文件创建位置如图所示： 2.7 编写测试类在测试类中 补充： 基于注解的mybatis使用 ①在持久层的方法上添加Sql语句的注解如： @Select(&quot;select * from user&quot;) ②修改SqlMapConfig.xml 三、自定义 Mybatis 框架实际开发中常使用mybatis代理jdbc所以在这里就不细说了 具体实现代码： Silencoco/SSM-Mybatis: SSM 框架之Mybatis学习 (github.com) 设计说明： 四、代理DAO实现CRUD操作Mybatis 与 JDBC 编程的比较 1.数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。解决：在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。 2.Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。 解决：将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。 3.向 sql 语句传参数麻烦，因为 sql 语句的 where 条件不一定，可能多也可能少，占位符需要和参数对应。 解决：Mybatis 自动将 java 对象映射至 sql 语句，通过 statement 中的 parameterType 定义输入参数的类型。 4.对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。 解决：Mybatis 自动将 sql 执行结果映射至 java 对象，通过 statement 中的 resultType 定义输出结果的类型 五、 Mybatis 的输出结果封装resultType 属性： 可以指定结果集的类型，它支持基本类型和实体类类型 同时，当是实体类名称是，还有一个要求，实体类中的属性名称必须和查询语句中的列名保持一致，否则无法实现封装。 resultMap 结果类型： resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。 在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。 六、SqlMapConfig.xml配置文件 properties****（属性）的两种配置方式 一、 二、在 classpath 下定义 db.properties 文件 dataSource 标签就变成了引用下面的配置 6.1 typeAliases（类型别名）在 SqlMapConfig.xml 中配置： 6.2 mappers（映射器）6.2.1 6.2.2 6.2.3 七、Mybatis 连接池与事务深入在 Mybatis 的 SqlMapConfig.xml 配置文件中，通过来实现 Mybatis 中连接池的配置 我们的数据源配置就是在 SqlMapConfig.xml 文件中，具体配置如下： MyBatis 在初始化时，根据的 type 属性来创建相应类型的的数据源 DataSource，即： type=”POOLED”：MyBatis 会创建 PooledDataSource 实例 type=”UNPOOLED” ： MyBatis 会创建 UnpooledDataSource 实例 type=”JNDI”：MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用 7.1 Mybatis 的事务控制​ 在 JDBC 中我们可以通过手动方式将事务的提交改为手动方式，通过 setAutoCommit()方法就可以调整。​ 那么我们的 Mybatis 框架因为是对 JDBC 的封装，所以 Mybatis 框架的事务控制方式，本身也是用 JDBC 的setAutoCommit()方法来设置事务提交方式的。 session.commit(); 7.1.1 Mybatis 自动提交事务的设置通过上面的研究和分析，现在我们一起思考，为什么 CUD 过程中必须使用 sqlSession.commit()提交事务？主要原因就是在连接池中取出的连接，都会将调用 connection.setAutoCommit(false)方法，这样我们就必须使用 sqlSession.commit()方法，相当于使用了 JDBC 中的 connection.commit()方法实现事务提交. 8. Mybatis 的动态 SQL 语句持久层： 测试类 9. Mybatis 中简化编写的 SQL 片段 八、Mybatis 多表查询之一对多、多对多一对多：需求： ​ 查询所有用户信息及用户关联的账户信息。 分析： ​ 用户信息和他的账户信息为一对多关系，并且查询过程中如果用户没有账户信息，此时也要将用户信息查询出来，我们想到了左外连接查询比较合适。 多对多：通过前面的学习，我们使用 Mybatis 实现一对多关系的维护。多对多关系其实我们看成是双向的一对多关系 九、 Mybatis 延迟加载策略9.1 什么是延迟加载延迟加载： ​ 就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载. 好处： ​ 先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。 坏处： ​ 因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。 9.2 实现需求需求： 查询账户(Account)信息并且关联查询用户(User)信息。如果先查询账户(Account)信息即可满足要求，当我们需要查询用户(User)信息时再查询用户(User)信息。把对用户(User)信息的按需去查询就是延迟加载。mybatis第三天实现多表操作时，我们使用了resultMap来实现一对一，一对多，多对多关系的操作。主要是通过 association、collection 实现一对一及一对多映射。association、collection 具备延迟加载功能。 9.3 使用 assocation 实现延迟加载 select： 填写我们要调用的 select 映射的 idcolumn ： 填写我们要传递给 select 映射的参数 持久层接口及映射文件 9.4 开启延迟加载 9.5 使用 Collection 实现延迟加载同样我们也可以在一对多关系配置的结点中配置延迟加载策略。结点中也有 select 属性，column 属性。需求：完成加载用户对象时，查询该用户所拥有的账户信息. 在 User 实体类中加入 **List**属性 编写用户和账户持久层接口的方法 编写用户持久层映射配置 标签：主要用于加载关联的集合对象select 属性：用于指定查询 account 列表的 sql 语句，所以填写的是该 sql 映射的 idcolumn 属性：用于指定 select 属性的 sql 语句的参数来源，上面的参数来自于 user 的 id 列，所以就写成 id 这一个字段名了 十、Mybatis 一级缓存​ 一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。 ​ 一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。 ​ 第一次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。 ​ 如果 sqlSession 去执行 commit 操作（执行插入、更新、删除），清空 SqlSession 中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 ​ 第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，缓存中有，直接从缓存中获取用户信息。 十一、二级缓存的开启与关闭第一步：在 SqlMapConfig.xml 文件开启二级缓存 因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false 代表不开启二级缓存。 第二步：配置相关的 Mapper 映射文件 标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。 配置 statement 上面的 useCache 属性 将 UserDao.xml 映射文件中的标签中设置 useCache=”true”代表当前这个 statement 要使用 二级缓存，如果不使用二级缓存可以设置为 false。 注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。 十二、 Mybatis 注解开发12.1 mybatis 的常用注解说明**@Insert:**实现新增 **@Update:**实现更新 **@Delete:**实现删除 **@Select:**实现查询 **@Result:**实现结果集封装 @Results:可以与@Result 一起使用，封装多个结果集 **@ResultMap:**实现引用@Results 定义的封装 **@One:**实现一对一结果集封装 **@Many:**实现一对多结果集封装 @SelectProvider: 实现动态 SQL 映射 **@CacheNamespace:**实现注解二级缓存的使用 12.2 使用注解实现复杂关系映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现，在使用注解开发时我们需要借 助@Results 注解，@Result 注解，@One 注解，@Many 注解。"},{"title":"JDBC快速入门","date":"2021-06-20T14:45:30.033Z","url":"/2021/06/20/JDBC%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","tags":[["JDBC","/tags/JDBC/"]],"categories":[["Java","/categories/Java/"]],"content":"一、JDBC快速入门：1.1 概念：Java DataBase Connectivity = Java 数据库连接。Java 语言操作数据库 1.2 JDBC本质：其实是官方定义的一套操作所有关系型数据库的规则，各个数据库厂商去实现这套接口，提供数据库驱动 jar 包。 我们可以使用这套接口（JDBC）编程，真正执行的代码时驱动 jar 包中的实现类。 1.3 快速入门：步骤： 代码实现： 二、对JDBC各个接口和类详解：2.1 DriverManager : 驱动管理对象 2.2 Connection : 数据库连接对象 2.3 Statement : 执行 sql 的对象 2.4 ResultSet : 结果集对象，封装查询结果 使用 Select 语句，把数据库表中的数据全部抓取出来，封装成集合对象，输出到控制台 emp 代码： JDBCDemo8代码： 2.5 JDBC 工具类 代码实现： 配置文件： 2.6 JDBC 练习：登录案例第一个版本：会被sql注入强行登录 2.7 PreparedStatement : 执行 sql 的对象 代码演示： 三、JDBC 控制事务： 代码："},{"title":"Git更新本地项目","date":"2021-06-02T13:27:00.231Z","url":"/2021/06/02/Git%E6%9B%B4%E6%96%B0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/","tags":[["git","/tags/git/"]],"categories":[["Git","/categories/Git/"]],"content":"Git更新本地项目1、（先进入项目文件夹）通过命令 git init 把这个目录变成git可以管理的仓库 2、把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件 3、用命令 git commit告诉Git，把文件提交到仓库。引号内为提交说明 4、关联到远程库 如： 5、获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败） 6、把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。 *、状态查询命令 关联 后更新只要执行步骤2、3、5、6。"},{"title":"网络编程初步学习","date":"2021-05-27T13:28:36.530Z","url":"/2021/05/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/","tags":[["Java","/tags/Java/"]],"categories":[["JavaSE","/categories/JavaSE/"]],"content":"第一章 网络编程入门1.1 软件结构 C/S结构：客户端和服务器结构，常见的有：QQ、迅雷等软件 B/S结构：浏览器和服务器结构，常见的有：谷歌、火狐等 1.2网络通信协议 网络通信协议 TCP/IP协议：传输控制协议/因特网互联协议。四层模型（应用层、传输层&lt;TCP、UDP&gt;、网络层、数据链路层和物理层） 1.3协议分类： UDP：用户数据报协议。面向无连接的通信协议，当一台计算机向另一台计算机发送数据时，发送端不会确认接收端是否存在，就会发送数据，同样接收端在收到数据时，也不会向发送端反馈是否接收到数据。 *优点**：消耗资源小，通信效率高，通常用于音频、视频和普通数据的传输。 *缺点**：不能保证数据的完整性，偶尔会丢失少量数据包。&lt;UDP相对于TCP而言，是缺少一个可靠的丢失重发机制，因此可以立即返回，所以你觉得快&gt; TCP：传输控制协议。面向连接的通信协议，传输数据前，先建立逻辑连接，再传输数据，提供了两台计算机间可靠的无差错的数据传输。在TCP连接中必须要明确客户端与服务器，由客户端发送连接请求，每次连接的创建都要经过“三次握手”。保证数据传输安全。 三次握手1、第一次握手：客户端向服务器发送连接请求，等待服务器确认。2、第二次握手：服务器向客户端回送一个响应。通知客户端收到了连接请求。3、第三次握手：客户端再次向服务器发送确认信息，确认连接。 1.4网络编程三要素①协议②IP地址 ipv4 32位的二进制数，通常被分为四个字节，可以表示2^32≈42亿个 ipv6 128位的十六进制数，每16个字节一组，分成8组，可以表示16^128个特殊的IP地址：127.0.0.1、localhost &lt;代表的都是本地的IP地址&gt; ③端口号 是一个逻辑端口，无法直接看到。由两个字节组成，取值范围在0-65535之间 *注意**：1、1024之前的端口号已经不能使用了，被系统分配到已知的网络软件了2、端口号不能重复 使用IP+端口号就能保证数据准确无误地发送到对方计算机的指定软件上了常见的端口号：1、80端口 网络端口 如：www.baidu.com:802、数据库 mysql:3306 oracle:15213、Tomcat服务器：8080 第二章：TCP通信程序2.1概述两端通信步骤：1、服务端程序，需要事先启动，等待客户端的连接2、客户端主动连接服务器端，连接成功才能实现通信。服务端不可以主动连接客户端。 在Java中，提供了两个类来实现TCP通信程序1、客户端：java.net.Socket类表示，创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。2、服务端：java.net.ServerSocket 类表示。创建 ServerSocket 对象，相当于开启一个服务，并等待客户端 的连接。 2.2 Socket类Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 构造方法：public Socket(String host, int port) :创建套接字对象并将其连接到指定主机上的指定端口号。如果指 定的host是null ，则相当于指定地址为回送地址。例如： 成员方法包括：getInputStream、getOutputStream、close、shutdownOutput. 具体实现：客户端类： 服务器类： "},{"title":"文章页面","date":"2021-05-23T18:06:57.000Z","url":"/2021/05/24/%E8%AE%BE%E7%BD%AE%E6%96%87%E7%AB%A0%E9%A1%B5%E9%9D%A2/","tags":[["hexo","/tags/hexo/"]],"categories":[["搭建初期","/categories/%E6%90%AD%E5%BB%BA%E5%88%9D%E6%9C%9F/"]],"content":"文章页面配置路径：顶部，文章信息区 (Front-Matter) pic : 可以指定这篇文章是否使用自定义的缩略图名称（在文章资源文件夹内），而不是使用随机化的图标 sticky : (number)重要的文章，把它们置顶吧！数字越大优先级越高哦~ comments : (true/false)是否为单篇文章指定开启或关闭评论区 toc： (true/false)该文章是否需要生成目录 only： 指定文章显示的位置，有以下关键词： home: 在首页显示 category: 在分类页显示 tag: 在标签页显示 留空或是不配置此项，则文章在所有该出现的位置都会显示。 层级之间相互平等，没有覆盖关系。 特别地，如果配置了此项，但是使用的并不是以上的关键词（例如只留了一个- none，那么文章就被隐藏起来了） 一个完整的 Front-Matter 区样式如下（可自行删去不必要的内容）： 模板与特定页面 书写技巧 文章概要 可以将文章开头的一段作为概要显示在首页主题部分，方法就是在需要分割的地方加入&lt;!-- more --&gt;即可；或者可以在文章头指定excerpt 图片资源 Hexo有为每篇文章生成一个资源文件夹，可以将图片资源以&#123;% asset_img 文件名 备注 %&#125;的格式插入文章，本主题引入的fancybox会自动实现对文章内图片的放大功能。 "},{"title":"使用hexo搭建个人博客","date":"2021-05-21T04:15:57.000Z","url":"/2021/05/21/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","tags":[["hexo","/tags/hexo/"]],"categories":[["搭建初期","/categories/%E6%90%AD%E5%BB%BA%E5%88%9D%E6%9C%9F/"]],"content":"一、使用hexo搭建个人博客初始化过程：&emsp;&emsp;进入hexo使用文档，下载git 和 node.js。&emsp;&emsp;遇到网速慢的情况可以自己配置国内镜像源，更改host文件。 二、使用 hexo -s 启动hexo服务，在本地端口localhost:4000进行效果预览 hexo n &quot;我的第一篇博客文章&quot; 新建一篇自己的博客文章，可以在VScode、typora等其他工具进行撰写语法一般使用markdown，基本语法参考：markdown简明语法 | 不如 (ibruce.info) .md文件一般放在 *\\source\\_posts\\ cd ../.. 完成编写后退回至原目录 hexo clean 进行清理 hexo g 进行生成 hexo d 进行部署 🐚补充：想要部署到通过GitHub的域名访问时repo为自己的仓库1、设置_config.yml文件 2、git config --global -l 设置部署到GitHub的用户名以及邮箱 三、设置主题在Themes | Hexo 中挑选合适的主题通过git克隆到本地的主题文件夹下git clone *** themes/&quot;主题名&quot;更改配置文件_config.yml(指定刚刚下载的主题) 🏆最后clean再部署启动一下就可以啦~ Ending···可以参考一下羊哥的视频：手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili 打开弹幕，遇到的绝大多数错误弹幕中都有提到"},{"title":"Hello World","date":"2021-05-20T23:34:42.104Z","url":"/2021/05/21/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]